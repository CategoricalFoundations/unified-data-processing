\documentclass{article}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{algorithm}
\usepackage{algorithmic}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}

\title{Complexity Lower Bound Proofs\\
\large Supplementary Material for PODS 2026 Submission}
\author{Anonymous}
\date{}

\begin{document}

\maketitle

\begin{abstract}
This document provides complete proofs for the complexity results in Section 8 
of the main paper. We establish tight $\Theta(n \log n)$ bounds for paradigm 
transformations and analyze join complexity via Kan extensions.
\end{abstract}

\section{Paradigm Transformation Complexity}

\begin{theorem}[Theorem 8.1: Tight Bounds]
Paradigm transformations $F_{BS}$ and $G_{SB}$ are $\Theta(n \log n)$ in the 
comparison model.
\end{theorem}

\subsection{Upper Bound: $O(n \log n)$}

\begin{proof}[Proof of Upper Bound]
We exhibit an algorithm achieving $O(n \log n)$ comparisons.

\textbf{Algorithm for $F_{BS}$:}
\begin{enumerate}
    \item Input: Batch $D = \{d_1, \ldots, d_n\}$
    \item Sort elements by timestamp assignment: $O(n \log n)$
    \item Create stream events with sorted timestamps: $O(n)$
    \item Output: Stream $S$ with $n$ events
\end{enumerate}

Total: $O(n \log n) + O(n) = O(n \log n)$ comparisons.

\textbf{Algorithm for $G_{SB}$:}
\begin{enumerate}
    \item Input: Stream $S$ with events $\{(v_1, t_1), \ldots, (v_n, t_n)\}$
    \item Extract first $W$ events (by watermark): $O(W)$
    \item Aggregate into multiset (using sorting): $O(W \log W)$
    \item Output: Batch $D$ with $\leq W$ elements
\end{enumerate}

Total: $O(W \log W) \subseteq O(n \log n)$ comparisons.
\end{proof}

\subsection{Lower Bound: $\Omega(n \log n)$}

\begin{proof}[Proof of Lower Bound]
We reduce sorting to paradigm transformation.

\textbf{Reduction from Sorting:}

Given an array $A = [a_1, \ldots, a_n]$ to sort:

\begin{enumerate}
    \item Create batch $D = \{|a_1|, \ldots, |a_n|\}$ (multiset)
    \item Apply $F_{BS}$ to get stream $S$ with timestamp-ordered events
    \item Read stream in timestamp order to get sorted output
\end{enumerate}

If $F_{BS}$ were $o(n \log n)$, we could sort in $o(n \log n)$ comparisons, 
contradicting the $\Omega(n \log n)$ lower bound for comparison-based sorting.

\textbf{Information-Theoretic Argument:}

A batch of $n$ distinct elements has $n!$ possible orderings.
The transformation must distinguish all orderings to produce correct timestamps.
Any comparison tree has height $\geq \log_2(n!) = \Omega(n \log n)$.

Therefore, $\Omega(n \log n)$ comparisons are necessary.
\end{proof}

\begin{corollary}
Paradigm transformations are $\Theta(n \log n)$.
\end{corollary}

\section{Join Complexity via Kan Extensions}

\begin{theorem}[Theorem 8.2: Join Complexity]
The Kan extension for $k$-way join is:
\begin{itemize}
    \item $O(n^k)$ via naive computation
    \item $O(n^{\mathrm{AGM}(Q)})$ via optimal algorithms
\end{itemize}
where $\mathrm{AGM}(Q)$ is the AGM bound for query $Q$.
\end{theorem}

\begin{proof}
\textbf{Naive Complexity:}

For $k$-way join $R_1 \bowtie R_2 \bowtie \cdots \bowtie R_k$:
\begin{itemize}
    \item Each relation has at most $n$ tuples
    \item Naive nested loop iterates over all $k$-tuples: $n^k$ iterations
    \item Each iteration performs $O(k)$ equality checks
\end{itemize}
Total: $O(k \cdot n^k) = O(n^k)$ for fixed $k$.

\textbf{Optimal Complexity via AGM:}

The AGM (Atserias-Grohe-Marx) bound gives:
\[
|R_1 \bowtie \cdots \bowtie R_k| \leq \prod_{i=1}^{k} |R_i|^{x_i}
\]
where $x_i$ solve the fractional edge cover LP.

Generic join algorithms (Leapfrog Triejoin, Minesweeper) achieve output-sensitive 
complexity matching this bound up to polylogarithmic factors.
\end{proof}

\section{Data Complexity}

\begin{theorem}[Theorem 8.3: Data Complexity]
For fixed query $Q$, the data complexity is:
\begin{itemize}
    \item $O(n)$ for selection and projection
    \item $O(n^2)$ for binary join
    \item $O(n^k)$ for $k$-way join
\end{itemize}
\end{theorem}

\begin{proof}
\textbf{Selection $\sigma_\phi$:}
Single pass over $n$ tuples, each evaluated in $O(1)$: Total $O(n)$.

\textbf{Projection $\pi_A$:}
Single pass with hash aggregation: $O(n)$ expected.

\textbf{Binary Join:}
Hash join: $O(n + m + |output|) = O(n^2)$ worst case.

\textbf{$k$-way Join:}
Worst case output size is $\Theta(n^k)$, which is optimal.
\end{proof}

\section{Combined Complexity}

\begin{theorem}[Theorem 8.4]
Combined complexity is $O(|Q| \cdot n^k)$ where $|Q|$ is query size and 
$k$ is the maximum join arity.
\end{theorem}

\begin{proof}
Query $Q$ is a tree of operators. Process bottom-up:
\begin{itemize}
    \item Each operator takes $O(n^{arity})$ time
    \item At most $|Q|$ operators
    \item Each produces at most $O(n^k)$ tuples
\end{itemize}
Total: $|Q| \cdot n^k$.
\end{proof}

\end{document}
